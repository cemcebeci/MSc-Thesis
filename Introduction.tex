Fuzzing is a software testing technique where the program under test is fed a large number of semi-random inputs, hoping to trigger unexpected behavior.
Thanks to its demonstrated effectiveness and practicality of application, fuzzing is one of the most popular techniques to discover bugs and vulnerabilities in software.
Fuzzing was conceived by Miller \textit{et al.} in 1988 \cite{Miller1999}.
They applied the method to test the reliability of UNIX utilities, programs that accept a single input consisting of an arbitrary string.
Over the last thirty years since the conception of fuzzing, it has been utilized in a multitude of fields to discover bugs in programs with more complex interfaces, such as compilers, network protocols and operating system kernels.

Despite its popularity in a wide range of fields, fuzzing is not very practical to apply to input intensive programs, such as games.
The main reason behind this is that games often have complex input patterns.
In contrast to the UNIX utilities Miller \textit{et al.} have fuzzed, games do not operate on a single potentially very large input.
Instead, they evolve with a multitude of actions taken by the players, as well as random events.
Therefore, a fuzzer for a game needs to interpret the fuzz input, an arbitrary set of bytes, as a sequence of actions on the game.
To illustrate why this is challenging, let us inspect backgammon as an example.

In a game of backgammon, on each turn, the player has to decide whether they want to offer their opponent the doubling cube.
Then, the opponent must decide to either accept the cube or concede.
After that, the player has to roll two six-sided dice.
Finally, they have to move two pieces each by the result of one of the dice.
We can identify at least four different kinds of actions to be taken on a game of backgammon: deciding whether to offer the doubling cube, deciding whether to accept, rolling the dice, using the dice to move pieces.
The different kinds of actions are not uniform in the input they accept.
The first two accept boolean inputs, the third one accepts two integers in the range $[1,6]$, and the last one accepts a piece to move.
These actions need to be performed in a certain order.
Furthermore, this order can not be statically determined.
For example, if the rolled dice are both three, the player needs to move four pieces as opposed to two.
Finally, not all pieces are moveable by an arbitrary amount, the dice the player rolls determine whether or not a particular piece is movable for the turn.
To summarize, forming valid sequences of action to feed to games can be a very complex task.

On the other hand, invalid sequences of actions do not make interesting test cases, since the game is expected to crash with these inputs.
Therefore, fuzzers that frequently parse the fuzz input into invalid sequences of actions perform poorly.
One option to obtain fuzzers that avoid producing invalid action sequences is to write them manually.
The fuzzer developer can utilize their knowledge about the game, as well as their skill in analyzing the game logic to develop custom parsing procedures for the fuzz input.
However, this option is both costly and error prone.
We would much rather have a procedure to automatically generate such fuzzers.
Such a procedure would need to know about the actions that can be taken on the game, in which game states each of these actions can be taken, and what parameters they can be taken with.

Fortunately, the program implementing the game needs to validate the actions players take and display error messages if they are not valid.
This requires the information about the possible actions, their availability and the constraints on their parameters to be present in the target program.
Therefore, compiler techniques should be able to extract this information already present in the program to emit high-quality fuzzers that avoid generating invalid action sequences.
The relevant information is available at compile time in the compiler for RuleBook (RL), a domain specific language designed to describe games and other input intensive simulations \cite{RLC}.
Motivated by this, the contribution of this work is as follows:
\begin{enumerate}
    \item We propose a method to automatically generate fuzzers for games described in RL, integrated within the compiler.
    \item We identify two factors leading to invalid action sequences: The generation of invocations to unavailable actions and the generation of illegal arguments to available actions. Then, we describe techniques to mitigate these two factors.
    \item We generate fuzzers for games implemented in OpenSpiel to form a reference for comparison.
    \item We measure the performance of four versions of fuzzers generated by the RL compiler as well as two versions of fuzzers for OpenSpiel games, varying in how much information about the game they utilize to avoid generating invalid action sequences.
    \item We compare the performances of these fuzzers to assess the impact of utilizing this information.
\end{enumerate}

\subsection*{Thesis organization}
The remaining part of this thesis is organized as follows:
\begin{description}
    \item [Chapter 2] Explains the motivation behind RL, demonstrates the problems it aims to solve and describes the structure of the language. In particular, the language features utilized by our fuzzing technique.
    \item [Chapter 3] Provides an overview of the technologies for compilers and fuzzing utilized by our method, as well as describing fuzzing and types of fuzzers in greater detail.
    \item [Chapter 4] Details our method of automatically generating fuzzers along with the key features to improve their performance.
    \item [Chapter 5] Describes our baseline of evaluation in the form of fuzzers for OpenSpiel games, details our experimental campaign on a selection of three benchmark games and presents the experimental results.
    \item [Chapter 6] Presents our conclusions and suggests future avenues of research related to our work. 
\end{description}
