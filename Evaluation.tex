In this chapter, we describe the experiments we conducted to evaluate the performance of the fuzzers we generate.
We measure the performance of the baseline black-box fuzzers, as well as the impact of our two major improvements to them: 
    avoiding generating calls to unavailable subactions and analyzing subaction preconditions to reduce the number of generated illegal arguments.
In addition, we describe another simple technique of automatically generating fuzzers for game descriptions that's completely independent from RL.
We use this technique to generate black-box and white-box fuzzers, and compare their performance with the RLC counterparts to assess the overall performance of using RL
    to fuzz game descriptions.

We evaluate the fuzzers on three sample games.
We introduce bugs in these games for the fuzzers to find.
In addition, we construct the games in a way that allows us to parametrize the minimum number of legal actions to be taken on the game in order to find the bug.
This allows us to investigate how the fuzzers' performance evolve as the bug complexity increases.

\section{Baseline}
In this section, we describe the baseline we use to evaluate the efficiency of fuzzers generated by RLC.
As a baseline, we need a simpler method of automatically generating fuzzers for game descriptions. Any such method
needs to establish an abstraction for how a game is described. We have chosen to use the abstraction of OpenSpiel, 
Google DeepMind's framework for applying reinforcement learning methods to games.

The OpenSpiel repository includes some example games. We describe two simple methods to generate white-box and black-box fuzz targets for these games.
These games, modified minimally to introduce bugs the fuzzer can find, form the baseline of our evaluation.

\subsection{Generating white-box fuzzers for OpenSpiel games} \label{osWhiteBox}
(TODO: I adapted this from the OpenSpiel paper, should figure out how to cite that.)
Games in OpenSpiel are described as procedural extensive-form games. Where a game has:
\begin{itemize}
    \item finite set of players. Including a special player representing chance.
    \item A finite set of all possible actions players can take in all game states.
    \item A finite set of histories. Each history is a sequence of actions that were taken from the start
    of the game.
    \item A finite set of terminal histories that represent a finished game.
    \item A utility for each player for each terminal history.
    \item A player assigned to take the next action for each non-terminal history. Including a special player representing simultaneous states, 
        where players act simultaneously choosing a joint action.
    \item A set of states, where each state is a set of histories such that histories in the same state can not be distinguished by the acting player.
\end{itemize}

Complete game descriptions are objects that implement some interface methods exposing the elements 
described above, along with some utility methods to simplify moving from a history to its successors.
In particular, OpenSpiel game descriptions implement the following methods that are useful for generating a fuzzer:
\begin{itemize}
    \item \texttt{Game::NewInitialState}
    \item \texttt{State::isTerminal}
    \item \texttt{State::isChanceNode}
    \item \texttt{State::isSimultaneousNode}
    \item \texttt{State::LegalChanceOutcomes}
    \item \texttt{State::LegalActions}
    \item \texttt{State::ApplyAction}
\end{itemize}
Depending only on these functions, we can generate a fuzz target analogous to the ones we generate for RL descriptions 
as shown in Algorithm~\ref{alg:var}, where $pickOne$ is a function that picks an element of the given set consuming the next $log_2(n)$ bits of 
the fuzz input. After generating the fuzz target, we plug the fuzz target into LLVM's libFuzzer
to generate the complete fuzzer.

\begin{algorithm}[H]
    \caption{White-box fuzzer for OpenSpiel games}
    \label{alg:var}
    \begin{algorithmic}[1]
    \STATE $state \gets game.NewInitialState()$
    \WHILE{$state.isTerminal()$}
        \IF{$state.isChanceNode()$}
            \STATE $nextAction \gets \pmb{pickOne}(state.LegalChanceOutcomes())$
        \ELSIF{$state.isSimultaneousNode()$}
            \STATE $actions \gets []$
            \FOR {$player \in players$}
                \STATE $actions.append(\pmb{pickOne}(state.LegalActions(player)))$
            \ENDFOR
            \STATE $nextAction \gets ApplyAction(actions)$
        \ELSE
            \STATE $nextAction \gets \pmb{pickOne}(state.LegalActions())$
        \ENDIF
        \STATE $state.ApplyAction(nextAction)$
    \ENDWHILE
    \end{algorithmic}
\end{algorithm}

It should be noted that OpenSpiel games may have two kinds of chance nodes. Explicit stochastic chance nodes
expose multiple legal actions, as well as a probability distribution over those actions. On the other hand, 
sampled stochastic chance nodes expose a single action with non-deterministic behavior. This fuzz target is 
only suitable for games with no sampled stochastic chance nodes since the fuzz target has to be deterministic
with respect to the fuzz input.

\subsection{Generating black-box fuzzers for OpenSpiel games} \label{osBlackBox}
The method to generate black-box fuzzers is very similar to its white-box alternative.
The white-box fuzzers have access to perfect information about what actions can be taken on the game at any given state.
They also know the complete action-space of the game.
In contrast, the black-box fuzzers should be analogous to the simple black-box fuzzers we described in Section\ref{blackboxFuzzTargets}.
The white-box fuzzers always pick legal actions thanks to the function call \texttt{state.LegalActions(player)}.
This returns the complete list of legal actions for the current game state, and the white-box fuzzer can pick among them.

Fortunately, OpenSpiel actions are represented by integers.
Therefore, the black-box fuzzers for OpenSpiel games can simply pick any integer as the action to be taken, as opposed to picking from a set of valid integers.
In this way, we obtain fuzzers analogous to the black-box fuzzers generated by RLC.

\section{Benchmarks}
In this section, we describe how our benchmarks are constructed.
We use three games from OpenSpiel samples as our benchmarks: \texttt{blackjack}, \texttt{tic\_tac\_toe} and \texttt{crazy\_eights}.
We modify these games lightly to introduce bugs in them for the fuzzers to find.
In parallel, we implement the same three games in RL, introducing the same bugs.

Furthermore, we want to be able to observe how the fuzzer performances change as the bugs become harder to discover.
In order to achieve this, we modify each game that allows us to control the minimum number of successive legal actions the fuzzer has to take before finding the bug
via a numeric parameter.
We call this parameter bug depth. Each game implements bug depth in a suitable form.

\subsubsection{Blackjack}
Blackjack is a simple card game played with a standard 52 card deck.
Cards 2-9 are worth points equal to their rank, face cards are all worth 10 points and aces are worth the player's choice of 1 or 11 points.
The goal is to get as close to 21 points without going above it.
Players all start the game with 2 cards in their hand.
Players take their turns in sequence. On a player's turn, they can choose to draw any number of cards as long as they do not surpass 21 points.
When they draw a card that puts them above 21 points, they lose the game.

The benchmark is blackjack played with one player and a dealer. The dealer does not explicitly take actions on the game.
When the player passes their turn, the dealer keeps drawing cards as long as they are more than 4 points short of the target score.
The bug is triggered when either the player or the dealer reached the target score exactly.

We modify the game with a bug depth parameter. This parameter controls the number of suits in the deck, as well as the target score.
The deck has $52 * bug\ depth$ cards and the target score is $21 * bug\ depth$. The dealer stops drawing at $21 * bug\ depth - 4$ points.
Since the point values of cards do not scale with bug depth, the number of cards a player has to draw before reaching the target score scales linearly with bug depth. 

\subsubsection{Tic Tac Toe}
Tic tac toe is a game where players take turns marking unmarked spaces in a 3x3 grid.
The first player to mark three spaces in a straight line, including the two diagonals, wins.

The benchmark is a sequence of tic tac toe games.
The two players player as many tic tac toe games as bug depth, and the bug triggers when a player wins the last game by marking all three spaces of the secondary diagonal.
Since the players need to reach the last game for the bug to trigger, they need to take a number of actions that scales linearly with bug depth.

\subsubsection{Crazy Eights}
Crazy eights is a precursor of UNO. It is played with a standard 52 card deck.
At the start fo the game, each player is dealt 7 cards.
Then, the top card of the deck is revealed. On their turn, the player can draw up to three cards, and play up to one card.
They can only play cards that have a matching suit or a matching rank with the last played card, or an eight.
When a player plays an eight, they pick the suit the next player has to match.
A player needs to draw all three cards if they do not play a card. Once a player plays a card, they can not draw more cards than turn.

Crazy eights can include special cards that make players draw additional cards, skip their turn, or reverse the turn order.
Our benchmark does not implement these special cards. The bug triggers when a player tries to draw from an empty deck.
Similarly to blackjack, the bug depth controls how many cards there are in the deck.
An increasing bug depth linearly increases the number of actions to be taken before reaching the bug.

\subsection{Experiments}
We measure the performance of fuzzers generated with six different methods the three games described above.
\begin{description}
    \item[rlc-full] is the fuzzer described in Chapter \ref{solutionDesign} including all mentioned improvements.
    This fuzzer is generated by invoking RLC with the --fuzzer flag.
    \item[rlc-no-fsm] is another fuzzer generated by RLC. However, this one does not avoid generating calls to unavailable subactions.
    It is generated by calling RLC with --fuzzer-avoid-unavailable-subactions=0 in addition to --fuzzer.
    \item[rlc-no-precons] is the version of \texttt{rlc-full} that does not analyze preconditions to generate reasonable subaction arguments.
    It is generated by passing RLC the --fuzzer-analyze-preconditions=0 flag in addition to --fuzzer.
    \item[rlc-blackbox] is generated by turning off both improvements when calling rlc.
    \item[os-whitebox] is the white-box fuzzer for OpenSpiel games described in Section \ref{osWhiteBox}.
    \item[os-blackbox] is the black-box version of \texttt{os-whitebox} described in Section \ref{osBlackBox}
\end{description}

We generate these six fuzzers for each benchmark for various bug depths.
We measure the average time taken to find the bug, as well as the average number of fuzz inputs tested.

\section{Results}
In this section, we present the results of our experiments and discuss our findings.
\subsection{Blackjack}
\subsection{Tic Tac Toe}

\subsection{Crazy Eights}
